/*
 * Copyright (c) 2021 PANTHEON.tech, s.r.o. All rights reserved.
 *
 *   This program and the accompanying materials are made available
 *   under the
 *   terms of the Eclipse Public License v1.0 which accompanies this
 *   distribution,  and is available at http://www.eclipse.org/legal/epl-v1.html
 */

{
 parserClass="tech.pantheon.yanginator.plugin.parser.YangParser"



  implements="tech.pantheon.yanginator.plugin.psi.YangNamedElement"
  extends="tech.pantheon.yanginator.plugin.psi.impl.YangNamedElementImpl"

  psiClassPrefix="Yang"
  psiImplClassSuffix="Impl"
  psiPackage="tech.pantheon.yanginator.plugin.psi"
  psiImplPackage="tech.pantheon.yanginator.plugin.psi.impl"

  elementTypeHolderClass="tech.pantheon.yanginator.plugin.psi.YangTypes"
  elementTypePrefix="YANG_"
  elementTypeClass="tech.pantheon.yanginator.plugin.psi.YangElementType"
  tokenTypeClass="tech.pantheon.yanginator.plugin.psi.YangTokenType"

  extends(".*stmt|unknown_statement.*")=Statement

  generateTokenAccessors=true
}

URI ::= scheme COLON hier-part [ QUESTION_MARK query ][HASH fragment ]

hier-part ::= "//" authority path-abempty
  | path-absolute
  | path-rootless
  | path-empty

URI-reference ::= URI | relative-ref

absolute-URI ::= scheme COLON hier-part [ QUESTION_MARK query ]

relative-ref ::= relative-part [ QUESTION_MARK query ][HASH fragment ]

relative-part ::= "//" authority path-abempty
  | path-absolute
  | path-noscheme
  | path-empty

scheme ::= ALPHA ( ALPHA | DIGIT | PLUS_SIGN | DASH | DOT )*

authority ::= [ userinfo AT_SIGN ] host [ COLON port ]
userinfo ::= ( unreserved | pct-encoded | sub-delims | COLON )*
host ::= IP-literal | IPv4address | reg-name
port ::= DIGIT*

IP-literal ::= OPEN_BRACKET ( IPv6address | IPvFuture ) CLOSED_BRACKET

IPvFuture ::= VERSION HEXDIG+ DOT ( unreserved | sub-delims | COLON )+

IPv6address ::= ( h16 COLON )(h16 COLON )(h16 COLON )(h16 COLON )(h16 COLON )(h16 COLON ) ls32
 | DOUBLE_COLON ( h16 COLON )(h16 COLON )(h16 COLON )(h16 COLON )(h16 COLON ) ls32
 | [ h16 ] DOUBLE_COLON ( h16 COLON )(h16 COLON )(h16 COLON )(h16 COLON ) ls32
 | [[  h16 COLON ] h16 ] DOUBLE_COLON ( h16 COLON )(h16 COLON )(h16 COLON ) ls32
 | [[  h16 COLON ][h16 COLON ] h16 ] DOUBLE_COLON ( h16 COLON )(h16 COLON ) ls32
 | [[  h16 COLON ][h16 COLON ][h16 COLON ] h16 ] DOUBLE_COLON h16 COLON ls32
 | [[  h16 COLON ][h16 COLON ][h16 COLON ][h16 COLON ] h16 ] DOUBLE_COLON ls32
 | [[  h16 COLON ][h16 COLON ][h16 COLON ][h16 COLON ][h16 COLON ] h16 ] DOUBLE_COLON h16
 | [[  h16 COLON ][h16 COLON ][h16 COLON ][h16 COLON ][h16 COLON ][h16 COLON ] h16 ] DOUBLE_COLON

h16 ::= (HEXDIG) | (HEXDIG HEXDIG) | (HEXDIG HEXDIG HEXDIG) | (HEXDIG HEXDIG HEXDIG HEXDIG)
ls32 ::= ( h16 COLON h16 ) | IPv4address
IPv4address ::= dec-octet DOT dec-octet DOT dec-octet DOT dec-octet

dec-octet ::= DIGIT // 0-9
 | POSITIVE_NUMBER DIGIT // 10-99
 | ONE DIGIT DIGIT // 100-199
 | TWO ( ZERO | ONE | TWO | THREE | FOUR ) DIGIT // 200-249
 | "25" ( ZERO | ONE | TWO | THREE | FOUR | FIVE ) // 250-255

reg-name ::= ( unreserved | pct-encoded | sub-delims )*

path ::= path-abempty // begins with FORWARD_SLASH or is empty
 | path-absolute // begins with FORWARD_SLASH but not "//"
 | path-noscheme // begins with a non-colon segment
 | path-rootless // begins with a segment
 | path-empty // zero characters

path-abempty ::= ( FORWARD_SLASH segment )*
path-absolute ::= FORWARD_SLASH [ segment-nz ( FORWARD_SLASH segment )* ]
path-noscheme ::= segment-nz-nc ( FORWARD_SLASH segment )*
path-rootless ::= segment-nz ( FORWARD_SLASH segment )*
path-empty ::= 0//pchar
segment ::= pchar*
segment-nz ::= pchar+
segment-nz-nc ::= ( unreserved | pct-encoded | sub-delims | AT_SIGN )+
 // non-zero-length segment without any colon COLON

pchar ::= unreserved | pct-encoded | sub-delims | COLON | AT_SIGN

query ::= ( pchar | FORWARD_SLASH | QUESTION_MARK )*

fragment ::= ( pchar | FORWARD_SLASH | QUESTION_MARK )*

pct-encoded ::= PERCENT_SIGN HEXDIG HEXDIG

unreserved ::= ALPHA | DIGIT | DASH | DOT | UNDERSCORE | TILDE
reserved ::= gen-delims | sub-delims
gen-delims ::= COLON | FORWARD_SLASH | QUESTION_MARK | HASH | OPEN_BRACKET | CLOSED_BRACKET | AT_SIGN
sub-delims ::= EXCLAMATION_MARK | DOLLAR_SIGN | AMPERSAND | SINGLE_QUOTE | LEFT_PARENTHESIS | RIGHT_PARENTHESIS
 | ASTERISK | PLUS_SIGN | COMMA | SEMICOLON | EQUALS
////////////////////////////// 
//
// RFC 3986
//
//////////////////////////////

URI ::= scheme COLON hier-part [ QUESTION_MARK query ][HASH fragment ]

hier-part ::= DOUBLE_PIPE authority path-abempty
 | path-absolute
 | path-rootless
 | path-empty

 URI-reference ::= URI | relative-ref

absolute-URI ::= scheme COLON hier-part [ QUESTION_MARK query ]

relative-ref ::= relative-part [ QUESTION_MARK query ][HASH fragment ]

relative-part ::= DOUBLE_PIPE authority path-abempty
 | path-absolute
 | path-noscheme
 | path-empty

scheme ::= ALPHA ( ALPHA | DIGIT | PLUS_SIGN | DASH | DOT )*

authority ::= [ userinfo AT_SIGN ] host [ COLON port ]
userinfo ::= ( unreserved | pct-encoded | sub-delims | COLON )*
 host ::= IP-literal | IPv4address | reg-name
 port ::= DIGIT*

IP-literal ::= OPEN_BRACKET ( IPv6address | IPvFuture ) CLOSED_BRACKET

IPvFuture ::= VERSION HEXDIG+ DOT ( unreserved | sub-delims | COLON )+

IPv6address ::= 6( h16 COLON ) ls32
 | DOUBLE_COLON 5( h16 COLON ) ls32
 | [ h16 ] DOUBLE_COLON 4( h16 COLON ) ls32
 | [ 1*( h16 COLON ) h16 ] DOUBLE_COLON 3( h16 COLON ) ls32
 | [ 2*( h16 COLON ) h16 ] DOUBLE_COLON 2( h16 COLON ) ls32
 | [ 3*( h16 COLON ) h16 ] DOUBLE_COLON h16 COLON ls32
 | [ 4*( h16 COLON ) h16 ] DOUBLE_COLON ls32
 | [ 5*( h16 COLON ) h16 ] DOUBLE_COLON h16
 | [ 6*( h16 COLON ) h16 ] DOUBLE_COLON

 h16 ::= 4HEXDIG+
ls32 ::= ( h16 COLON h16 ) | IPv4address
IPv4address ::= dec-octet DOT dec-octet DOT dec-octet DOT dec-octet

dec-octet ::= DIGIT // 0-9
 | POSITIVE_NUMBER DIGIT // 10-99
 | ONE 2DIGIT // 100-199
 | TWO ( ZERO | ONE | TWO | THREE | FOUR ) DIGIT // 200-249
 | TWO FIVE ( ZERO | ONE | TWO | THREE | FOUR | FIVE ) // 250-255

 reg-name ::= ( unreserved | pct-encoded | sub-delims )*

path ::= path-abempty // begins with FORWARD_SLASH or is empty
 | path-absolute // begins with FORWARD_SLASH but not "//"
 | path-noscheme // begins with a non-colon segment
 | path-rootless // begins with a segment
 | path-empty // zero characters

path-abempty ::= ( FORWARD_SLASH segment )*
path-absolute ::= FORWARD_SLASH [ segment-nz ( FORWARD_SLASH segment )* ]
path-noscheme ::= segment-nz-nc ( FORWARD_SLASH segment )*
path-rootless ::= segment-nz ( FORWARD_SLASH segment )*
 path-empty ::= 0//pchar 
 segment ::= pchar*
 segment-nz ::= pchar+
segment-nz-nc ::= ( unreserved | pct-encoded | sub-delims | AT_SIGN )+
 // non-zero-length segment without any colon COLON

pchar ::= unreserved | pct-encoded | sub-delims | COLON | AT_SIGN

query ::= ( pchar | FORWARD_SLASH | QUESTION_MARK )*

fragment ::= ( pchar | FORWARD_SLASH | QUESTION_MARK )*

pct-encoded ::= PERCENT_SIGN HEXDIG HEXDIG

unreserved ::= ALPHA | DIGIT | DASH | DOT | UNDERSCORE | TILDE
 reserved ::= gen-delims | sub-delims
gen-delims ::= COLON | FORWARD_SLASH | QUESTION_MARK | HASH | OPEN_BRACKET | CLOSED_BRACKET | AT_SIGN
sub-delims ::= EXCLAMATION_MARK | DOLLAR_SIGN | AMPERSAND | SINGLE_QUOTE | LEFT_PARENTHESIS | RIGHT_PARENTHESIS
 | ASTERISK | PLUS_SIGN | COMMA | SEMICOLON | EQUALS
////////////////////////////// 
//
// HIGHLITER STUFF
//
//////////////////////////////

h_identifier-literal ::=
    H_ANYXML_KEYWORD          |
    H_ARGUMENT_KEYWORD        |
    H_AUGMENT_KEYWORD         |
    H_BASE_KEYWORD            |
    H_BELONGS_TO_KEYWORD      |
    H_BIT_KEYWORD             |
    H_CASE_KEYWORD            |
    H_CHOICE_KEYWORD          |
    H_CONFIG_KEYWORD          |
    H_CONTACT_KEYWORD         |
    H_CONTAINER_KEYWORD       |
    H_DEFAULT_KEYWORD         |
    H_DESCRIPTION_KEYWORD     |
    H_ENUM_KEYWORD            |
    H_ERROR_APP_TAG_KEYWORD   |
    H_ERROR_MESSAGE_KEYWORD   |
    H_EXTENSION_KEYWORD       |
    H_DEVIATION_KEYWORD       |
    H_DEVIATE_KEYWORD         |
    H_FEATURE_KEYWORD         |
    H_FRACTION_DIGITS_KEYWORD |
    H_GROUPING_KEYWORD        |
    H_IDENTITY_KEYWORD        |
    H_IF_FEATURE_KEYWORD      |
    H_IMPORT_KEYWORD          |
    H_INCLUDE_KEYWORD         |
    H_INPUT_KEYWORD           |
    H_KEY_KEYWORD             |
    H_LEAF_KEYWORD            |
    H_LEAF_LIST_KEYWORD       |
    H_LENGTH_KEYWORD          |
    H_LIST_KEYWORD            |
    H_MANDATORY_KEYWORD       |
    H_MAX_ELEMENTS_KEYWORD    |
    H_MIN_ELEMENTS_KEYWORD    |
    H_MODULE_KEYWORD          |
    H_MUST_KEYWORD            |
    H_NAMESPACE_KEYWORD       |
    H_NOTIFICATION_KEYWORD    |
    H_ORDERED_BY_KEYWORD      |

    H_ORGANIZATION_KEYWORD    |
    H_OUTPUT_KEYWORD          |
    H_PATH_KEYWORD            |
    H_PATTERN_KEYWORD         |
    H_POSITION_KEYWORD        |
    H_PREFIX_KEYWORD          |
    H_PRESENCE_KEYWORD        |
    H_RANGE_KEYWORD           |
    H_REFERENCE_KEYWORD       |
    H_REFINE_KEYWORD          |
    H_REQUIRE_INSTANCE_KEYWORD|
    H_REVISION_KEYWORD        |
    H_REVISION_DATE_KEYWORD   |
    H_RPC_KEYWORD             |
    H_STATUS_KEYWORD          |
    H_SUBMODULE_KEYWORD       |
    H_TYPE_KEYWORD            |
    H_TYPEDEF_KEYWORD         |
    H_UNIQUE_KEYWORD          |
    H_UNITS_KEYWORD           |
    H_USES_KEYWORD            |
    H_VALUE_KEYWORD           |
    H_WHEN_KEYWORD            |
    H_YANG_VERSION_KEYWORD    |
    H_YIN_ELEMENT_KEYWORD     |

    // other keywords

    H_CURRENT_KEYWORD         |
    H_DELETE_KEYWORD          |
    H_DEPRECATED_KEYWORD      |
    H_FALSE_KEYWORD           |
    H_ADD_KEYWORD             |
    H_MAX_KEYWORD             |
    H_MIN_KEYWORD             |
    H_NOT_SUPPORTED_KEYWORD   |
    H_OBSOLETE_KEYWORD        |
    H_REPLACE_KEYWORD         |
    H_SYSTEM_KEYWORD          |
    H_TRUE_KEYWORD            |
    H_UNBOUNDED_KEYWORD       |
    H_USER_KEYWORD            |
    H_SEMICOLON

// u just need to add tokens from highlighter there so u can generate parser code only from this file
highlighter-tokens ::= H_NOT_STRING | H_STRING | H_WHITE_SPACE | H_DATE_ARG | H_IDENTIFIER |  H_EXTENSION_IDENTIFIER |
    H_BLOCK_COMMENT | H_SINGLE_LINE_COMMENT | BLOCK_COMMENT_END | H_FS | H_A

private Statements ::= StatementWithSemi*
private StatementWithSemi ::= Statement (SEMICOLON |& RIGHT_BRACE) { pin=1 recoverWhile=StatementRecover }
Statement ::=
    deviate-replace-stmt
  | deviate-delete-stmt
  | deviate-add-stmt
  | deviate-not-supported-stmt
  | deviation-stmt
  | notification-stmt
  | output-stmt
  | input-stmt
  | rpc-stmt
  | when-stmt
  | augment-stmt
  | uses-augment-stmt
  | refine-stmt
  | uses-stmt
  | anyxml-stmt
  | case-stmt
  | short-case-stmt
  | choice-stmt
  | unique-stmt
  | key-stmt
  | list-stmt
  | leaf-list-stmt
  | leaf-stmt
  | container-stmt
  | grouping-stmt
  | value-stmt
  | max-elements-stmt
  | min-elements-stmt
  | error-app-tag-stmt
  | error-message-stmt
  | must-stmt
  | ordered-by-stmt
  | presence-stmt
  | mandatory-stmt
  | config-stmt
  | status-stmt
  | position-stmt
  | bit-stmt
  | require-instance-stmt
  | path-stmt
  | enum-stmt
  | default-stmt
  | pattern-stmt
  | length-stmt
  | fraction-digits-stmt
  | range-stmt
  | type-stmt
  | typedef-stmt
  | if-feature-stmt
  | feature-stmt
  | base-stmt
  | identity-stmt
  | yin-element-stmt
  | argument-stmt
  | extension-stmt
  | revision-date-stmt
  | revision-stmt
  | units-stmt
  | reference-stmt
  | description-stmt
  | contact-stmt
  | organization-stmt
  | belongs-to-stmt
  | prefix-stmt
  | namespace-stmt
  | include-stmt
  | import-stmt
  | yang-version-stmt
  | unknown-statement
